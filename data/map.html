<!--
******************************************************************************
*
* $Id: map.html
*
* Project:  WindNinja
* Purpose:  Map Layer used to download and display landscape data
* Author:   Mason Willman <mason.willman@usda.gov>
*
******************************************************************************
*
* THIS SOFTWARE WAS DEVELOPED AT THE ROCKY MOUNTAIN RESEARCH STATION (RMRS)
* MISSOULA FIRE SCIENCES LABORATORY BY EMPLOYEES OF THE FEDERAL GOVERNMENT
* IN THE COURSE OF THEIR OFFICIAL DUTIES. PURSUANT TO TITLE 17 SECTION 105
* OF THE UNITED STATES CODE, THIS SOFTWARE IS NOT SUBJECT TO COPYRIGHT
* PROTECTION AND IS IN THE PUBLIC DOMAIN. RMRS MISSOULA FIRE SCIENCES
* LABORATORY ASSUMES NO RESPONSIBILITY WHATSOEVER FOR ITS USE BY OTHER
* PARTIES,  AND MAKES NO GUARANTEES, EXPRESSED OR IMPLIED, ABOUT ITS QUALITY,
* RELIABILITY, OR ANY OTHER CHARACTERISTIC.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*
******************************************************************************
-->

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Leaflet Map</title>
    <style>
        html, body 
        {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            box-sizing: border-box;
        }
        #map 
        {
            height: 100%;
            width: 100%;
            box-sizing: border-box;
        }
    </style>

    <!-- Leaflet stylesheets -->
    <link rel="stylesheet" href="leaflet/leaflet.css"/>
    <link rel="stylesheet" href="leaflet/draw/src/leaflet.draw.css"/>
    <link rel="stylesheet" href="leaflet/L.Control.Layers.Tree.css" />

    <!-- Leaflet and Draw dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script src="./leaflet/leaflet-src.js"></script>
    <script src="./leaflet/L.KML.js"></script>

    <script src="./leaflet/L.Control.Layers.Tree.js"></script>

    <script src="./leaflet/draw/src/Leaflet.draw.js"></script>
    <script src="./leaflet/draw/src/Leaflet.Draw.Event.js"></script>

    <script src="./leaflet/draw/src/draw/handler/Draw.Feature.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.SimpleShape.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Rectangle.js"></script>

    <script src="./leaflet/draw/src/edit/handler/Edit.SimpleShape.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.Rectangle.js"></script>

    <script src="./leaflet/draw/src/Control.Draw.js"></script>
    <script src="./leaflet/draw/src/Toolbar.js"></script>
    <script src="./leaflet/draw/src/draw/DrawToolbar.js"></script>
    <script src="./leaflet/draw/src/edit/EditToolbar.js"></script>
    <script src="./leaflet/draw/src/edit/handler/EditToolbar.Edit.js"></script>
    <script src="./leaflet/draw/src/edit/handler/EditToolbar.Delete.js"></script>

    

    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
</head>
<body>
    <div id="map" style="border: 1px solid #ccc"></div>
    <script>

        // Script variables
        const apiKey = "pk.eyJ1IjoiYm5vcmRncmVuIiwiYSI6ImNsZmxuMHowZzAzaTczeG80ZXR3a2ZnNHEifQ.kc7P57DJg8tyDMjjP7czuQ";

        const streetBaseLayer = L.tileLayer(`https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=${apiKey}`, {
            tileSize: 512,
            maxZoom: 18,
            zoomOffset: -1,
            id: 'mapbox/streets-v11'
        });

        const satelliteBaseLayer = L.tileLayer(`https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=${apiKey}`, {
            tileSize: 512,
            maxZoom: 18,
            zoomOffset: -1,
            id: 'mapbox/satellite-v9'
        });

        const map = new L.Map('map', {
            layers: [streetBaseLayer],
            center: new L.LatLng(43.62455, -113.2971),
            zoom: 8
        });
        
        const mapRectangleLayer = new L.FeatureGroup();
        const rectangleDrawer = new L.Draw.Rectangle(map);
        const centerControl = L.control({ position: 'topleft' });
        
        const baseTree = {
            label: 'Base Maps',
            children: [
                {
                    label: 'Mapbox Streets',
                    layer: streetBaseLayer
                },
                {
                    label: 'Satellite',
                    layer: satelliteBaseLayer
                }
            ]
        };

        const simulationTree = {
            label: 'Forecast Simulations',
            children: []
        };

        const demTree= {
            label: 'DEM Simulations',
            children: []
        };

        const overlayTree = {
            label: 'Overlays',
            children: [
                {
                    label: 'Bounding Box',
                    layer: mapRectangleLayer
                }
            ]
        };

        const layerControl = L.control.layers.tree(
            baseTree,
            overlayTree,
            {
                collapsed: true
            }
        );

        let drawDEMCheck = false;

        let kmzBaseLayers = [];
        let kmzLegendControls = [];
        
        let centerControlAdded = false;

        // Script functions

        function sendBoundingBox(layer) {
            const bounds = layer.getBounds();
            const bboxData = {
                north: bounds.getNorth(),
                south: bounds.getSouth(),
                east: bounds.getEast(),
                west: bounds.getWest()
            };

            if (window.bridge?.receiveBoundingBox) {
                window.bridge.receiveBoundingBox(JSON.stringify(bboxData));
            }
        }

        function drawBoundingBox(north, south, east, west) {
            mapRectangleLayer.clearLayers();
            const bounds = [[south, west], [north, east]];
            const rectangle = L.rectangle(bounds).addTo(mapRectangleLayer);
            rectangle.editing.enable();
            sendBoundingBox(rectangle);
            map.fitBounds(rectangle.getBounds());
            rectangle.on('edit', () => {
                    sendBoundingBox(rectangle);
                    map.fitBounds(rectangle.getBounds()); 
            });
        }

        function drawDEM(DEMCorners) {
            mapRectangleLayer.clearLayers();

            const rectangleCorners = [
                [DEMCorners[1], DEMCorners[0]], // NE
                [DEMCorners[3], DEMCorners[2]], // SE
                [DEMCorners[5], DEMCorners[4]], // SW
                [DEMCorners[7], DEMCorners[6]], // NW
                [DEMCorners[1], DEMCorners[0]]  // NE
            ];

            const rectangle = L.polygon(rectangleCorners, {
                color: 'black',
                weight: 2,
                fill: false
            }).addTo(mapRectangleLayer);

            setTimeout(() => {
                map.fitBounds(rectangle.getBounds());
            }, 5000);

            showCenterControl();
        }

        function startRectangleDrawing() {
            mapRectangleLayer.clearLayers();
            rectangleDrawer.enable();
        }

        function stopRectangleDrawing() {
            mapRectangleLayer.clearLayers();
            
            if(!drawDEMCheck) {
                hideCenterControl();
            }
            
            rectangleDrawer.disable();
        }

        map.on('draw:created', ({ layer }) => {
            mapRectangleLayer.clearLayers();
            mapRectangleLayer.addLayer(layer);
            layer.editing.enable();
            sendBoundingBox(layer);
            layer.on('edit', () => 
            {
                sendBoundingBox(layer);
                map.fitBounds(layer.getBounds());
            });
            map.fitBounds(layer.getBounds());
            showCenterControl();
        });

        function showCenterControl() {
            if (!centerControlAdded) {
                centerControl.addTo(map);
                centerControlAdded = true;
            }
        }

        function hideCenterControl() {
            if (centerControlAdded) {
                map.removeControl(centerControl);
                centerControlAdded = false;
            }
        }

        centerControl.onAdd = function(map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-center');
            const button = L.DomUtil.create('a', '', container);
            button.innerHTML = 'âŒ–';
            button.title = 'Center on current shape';
            button.href = '#';

            L.DomEvent.on(button, 'click', (e) => {
                L.DomEvent.stopPropagation(e);
                L.DomEvent.preventDefault(e);
                if (mapRectangleLayer.getLayers().length > 0) {
                    const layer = mapRectangleLayer.getLayers()[0];
                    if (layer.getBounds) {
                        map.fitBounds(layer.getBounds());
                    }
                }
            });

            return container;
        };

        async function loadKmzFromBase64(kmlData, timeSeries) {
            clearKmzBaseLayers();
            const binary = atob(kmlData);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            const zip = await JSZip.loadAsync(bytes.buffer);

            const kmlEntries = Object.values(zip.files).filter(entry =>
                entry.name.toLowerCase().endsWith('.kml')
            );
            const legendEntries = Object.values(zip.files).filter(entry =>
                entry.name.toLowerCase().endsWith('.bmp')
            );

            if (kmlEntries.length === 0) {
                alert('No KML files found in this KMZ.');
                return;
            }

            for (const entry of kmlEntries) {
                const kmlText = await entry.async('string');
                const parser = new DOMParser();
                const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
                const kmlLayer = new L.KML(kmlDoc);

                const kmlLegendLayer = L.layerGroup([kmlLayer]);

                const layerName = entry.name;

                const legendControl = L.control({ position: 'bottomright' });
                kmzLegendControls.push(legendControl);

                legendControl.onAdd = function () {
                    const container = L.DomUtil.create('div', 'kmz-legend');
                    L.DomEvent.disableClickPropagation(container);


                    if (legendEntries.length > 0) {
                        (async () => {
                            const legendEntry = legendEntries[0]; // Grabs only the legend
                            const blob = await legendEntry.async('blob');
                            const url = URL.createObjectURL(blob);

                            const img = new Image();
                            img.src = url;
                            img.style.display = 'block';
                            img.style.maxWidth = '150px'; 
                            img.style.height = 'auto';

                            container.appendChild(img);

                    if (timeSeries && legendEntries.length > 1) {
                        const legendEntry2 = legendEntries[1];
                        const blob2 = await legendEntry2.async('blob');
                        const url2 = URL.createObjectURL(blob2);

                        const img2 = new Image();
                        img2.src = url2;
                        img2.style.position = 'absolute';
                        img2.style.top = '10px';
                        img2.style.left = '50%';
                        img2.style.transform = 'translateX(-50%)';
                        img2.style.maxWidth = '90%'; // prevents it from overflowing the map
                        img2.style.height = 'auto';
                        img2.style.zIndex = '600';
                        img2.className = 'kmz-time-series-legend';

                        // Append directly to the map container
                        map.getContainer().appendChild(img2);
}
                        })();
                    }

                    return container;
                };

                kmlLegendLayer.on('add', () => legendControl.addTo(map));
                kmlLegendLayer.on('remove', () => legendControl.remove());

                layerControl.addBaseLayer(kmlLegendLayer, layerName);
                kmzBaseLayers.push(kmlLegendLayer);

            }
        }

        // Main

        if (window.qt) {
            new QWebChannel(qt.webChannelTransport, channel => {
                window.bridge = channel.objects.bridge;
            });
        }
        
        map.addLayer(mapRectangleLayer);

        layerControl.addTo(map);
        L.control.scale().addTo(map);

        
    </script>
</body>
</html>
