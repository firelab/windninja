<!--
******************************************************************************
*
* $Id: map.html
*
* Project:  WindNinja
* Purpose:  Map Layer used to download and display landscape data
* Author:   Mason Willman <mason.willman@usda.gov>
*
******************************************************************************
*
* THIS SOFTWARE WAS DEVELOPED AT THE ROCKY MOUNTAIN RESEARCH STATION (RMRS)
* MISSOULA FIRE SCIENCES LABORATORY BY EMPLOYEES OF THE FEDERAL GOVERNMENT
* IN THE COURSE OF THEIR OFFICIAL DUTIES. PURSUANT TO TITLE 17 SECTION 105
* OF THE UNITED STATES CODE, THIS SOFTWARE IS NOT SUBJECT TO COPYRIGHT
* PROTECTION AND IS IN THE PUBLIC DOMAIN. RMRS MISSOULA FIRE SCIENCES
* LABORATORY ASSUMES NO RESPONSIBILITY WHATSOEVER FOR ITS USE BY OTHER
* PARTIES,  AND MAKES NO GUARANTEES, EXPRESSED OR IMPLIED, ABOUT ITS QUALITY,
* RELIABILITY, OR ANY OTHER CHARACTERISTIC.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*
******************************************************************************
-->

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Leaflet Map</title>
    <style>
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            box-sizing: border-box;
        }
        #map {
            height: 100%;
            width: 100%;
            box-sizing: border-box;
        }
        .leaflet-div-icon {
            background: white;
            border: 2px solid #0077ff;
            border-radius: 50%;
            width: 10px !important;
            height: 10px !important;
            margin-left: -5px !important;
            margin-top: -5px !important;
            box-shadow: 0 0 1px #000;
        }
        .leaflet-drag-target {
            cursor: move !important;
        }
        .leaflet-control-center {
        background: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .leaflet-control-center a {
            display: block;
            text-align: center;
            color: #0077ff;
            font-size: 20px;
            line-height: 26px;
            width: 28px;
            height: 28px;
            text-decoration: none;
        }
        .leaflet-control-center a:hover {
            background: #0077ff;
            color: white;
        }
        .leaflet-topcenter {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1000;
    pointer-events: none;
}

.kmz-top-center-legend img {
    display: block;
}

    </style>

    <link rel="stylesheet" href="leaflet/leaflet.css"/>
    <link rel="stylesheet" href="leaflet/draw/src/leaflet.draw.css"/>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- Leaflet and Draw dependencies -->
    <script src="./leaflet/leaflet-src.js"></script>
    <script src="./leaflet/L.KML.js"></script>

    <script src="./leaflet/draw/src/Leaflet.draw.js"></script>
    <script src="./leaflet/draw/src/Leaflet.Draw.Event.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.Poly.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.SimpleShape.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.Rectangle.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.Marker.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.CircleMarker.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.Circle.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Feature.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Polyline.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Polygon.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.SimpleShape.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Rectangle.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Circle.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Marker.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.CircleMarker.js"></script>
    <script src="./leaflet/draw/src/ext/TouchEvents.js"></script>
    <script src="./leaflet/draw/src/ext/LatLngUtil.js"></script>
    <script src="./leaflet/draw/src/ext/GeometryUtil.js"></script>
    <script src="./leaflet/draw/src/ext/LineUtil.Intersect.js"></script>
    <script src="./leaflet/draw/src/ext/Polyline.Intersect.js"></script>
    <script src="./leaflet/draw/src/ext/Polygon.Intersect.js"></script>
    <script src="./leaflet/draw/src/Control.Draw.js"></script>
    <script src="./leaflet/draw/src/Tooltip.js"></script>
    <script src="./leaflet/draw/src/Toolbar.js"></script>
    <script src="./leaflet/draw/src/draw/DrawToolbar.js"></script>
    <script src="./leaflet/draw/src/edit/EditToolbar.js"></script>
    <script src="./leaflet/draw/src/edit/handler/EditToolbar.Edit.js"></script>
    <script src="./leaflet/draw/src/edit/handler/EditToolbar.Delete.js"></script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
</head>
<body>
    <div id="map" style="border: 1px solid #ccc"></div>
    <script>
        const apiKey = "pk.eyJ1IjoiYm5vcmRncmVuIiwiYSI6ImNsZmxuMHowZzAzaTczeG80ZXR3a2ZnNHEifQ.kc7P57DJg8tyDMjjP7czuQ";

        const mapBaseLayer = L.tileLayer(`https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=${apiKey}`, {
            tileSize: 512,
            maxZoom: 18,
            zoomOffset: -1,
            id: 'mapbox/streets-v11'
        });

        const map = new L.Map('map', {
            layers: [mapBaseLayer],
            center: new L.LatLng(43.62455, -113.2971),
            zoom: 8
        });
        

        const mapRectangleLayer = new L.FeatureGroup();
        map.addLayer(mapRectangleLayer);

        const rectangleDrawer = new L.Draw.Rectangle(map);

        function sendBoundingBox(layer) {
            const bounds = layer.getBounds();
            const bboxData = {
                north: bounds.getNorth(),
                south: bounds.getSouth(),
                east: bounds.getEast(),
                west: bounds.getWest()
            };
            if (window.bridge?.receiveBoundingBox) {
                window.bridge.receiveBoundingBox(JSON.stringify(bboxData));
            }
        }

        function drawBoundingBox(north, south, east, west) {
            mapRectangleLayer.clearLayers();
            const bounds = [[south, west], [north, east]];
            const rectangle = L.rectangle(bounds).addTo(mapRectangleLayer);
            rectangle.editing.enable();
            sendBoundingBox(rectangle);
            map.fitBounds(rectangle.getBounds());
            rectangle.on('edit', () => {
                sendBoundingBox(rectangle);
                map.fitBounds(rectangle.getBounds()); 
            });
        }

        function drawDEM(DEMCorners) {
            mapRectangleLayer.clearLayers();

            const rectangleCorners = [
                [DEMCorners[1], DEMCorners[0]], // NE
                [DEMCorners[3], DEMCorners[2]], // SE
                [DEMCorners[5], DEMCorners[4]], // SW
                [DEMCorners[7], DEMCorners[6]], // NW
                [DEMCorners[1], DEMCorners[0]]  // NE
            ];

            const rectangle = L.polygon(rectangleCorners, {
                color: 'black',
                weight: 2,
                fill: false
            }).addTo(mapRectangleLayer);

            setTimeout(() => {
                map.fitBounds(rectangle.getBounds());
            }, 5000);

            showCenterControl();
        }

        function startRectangleDrawing() {
            mapRectangleLayer.clearLayers();
            rectangleDrawer.enable();
        }

        function stopRectangleDrawing() {
            mapRectangleLayer.clearLayers();
            if(!drawDEMCheck) {
                hideCenterControl();
            }
            rectangleDrawer.disable();
        }

        let activeKmzLayer = null;

        async function loadKmzFromBase64(kmlData, timeSeries) {
            clearKmzBaseLayers();
            const binary = atob(kmlData);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            const zip = await JSZip.loadAsync(bytes.buffer);

            const kmlEntries = Object.values(zip.files).filter(entry =>
                entry.name.toLowerCase().endsWith('.kml')
            );
            const legendEntries = Object.values(zip.files).filter(entry =>
                entry.name.toLowerCase().endsWith('.bmp')
            );

            if (kmlEntries.length === 0) {
                alert('No KML files found in this KMZ.');
                return;
            }

            for (const entry of kmlEntries) {
                const kmlText = await entry.async('string');
                const parser = new DOMParser();
                const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
                const kmlLayer = new L.KML(kmlDoc);

                const kmlLegendLayer = L.layerGroup([kmlLayer]);

                const layerName = entry.name;

                const legendControl = L.control({ position: 'bottomright' });
                kmzLegendControls.push(legendControl);

                legendControl.onAdd = function () {
                    const container = L.DomUtil.create('div', 'kmz-legend');
                    L.DomEvent.disableClickPropagation(container);


                    if (legendEntries.length > 0) {
                        (async () => {
                            const legendEntry = legendEntries[0]; // Grabs only the legend
                            const blob = await legendEntry.async('blob');
                            const url = URL.createObjectURL(blob);

                            const img = new Image();
                            img.src = url;
                            img.style.display = 'block';
                            img.style.maxWidth = '150px'; 
                            img.style.height = 'auto';

                            container.appendChild(img);

                    if (timeSeries && legendEntries.length > 1) {
    const legendEntry2 = legendEntries[1];
    const blob2 = await legendEntry2.async('blob');
    const url2 = URL.createObjectURL(blob2);

    const img2 = new Image();
    img2.src = url2;
    img2.style.position = 'absolute';
    img2.style.top = '10px';
    img2.style.left = '50%';
    img2.style.transform = 'translateX(-50%)';
    img2.style.maxWidth = '90%'; // prevents it from overflowing the map
    img2.style.height = 'auto';
    img2.style.zIndex = '600';
    img2.className = 'kmz-time-series-legend';

    // Append directly to the map container
    map.getContainer().appendChild(img2);
}
                        })();
                    }

                    return container;
                };

                kmlLegendLayer.on('add', () => legendControl.addTo(map));
                kmlLegendLayer.on('remove', () => legendControl.remove());

                layerControl.addBaseLayer(kmlLegendLayer, layerName);
                kmzBaseLayers.push(kmlLegendLayer);

                if (!layerControlAdded) {
                    layerControl.addTo(map);
                    layerControlAdded = true;
                }

                if (!activeKmzLayer) {
                    activeKmzLayer = kmlLegendLayer;
                    kmlLegendLayer.addTo(map);
                }
            }
        }


        map.on('draw:created', ({ layer }) => {
            mapRectangleLayer.clearLayers();
            mapRectangleLayer.addLayer(layer);
            layer.editing.enable();
            sendBoundingBox(layer);
            layer.on('edit', () => {
                sendBoundingBox(layer);
                map.fitBounds(layer.getBounds());
            });
            map.fitBounds(layer.getBounds());
            showCenterControl();
        });

        function showCenterControl() {
            if (!centerControlAdded) {
                centerControl.addTo(map);
                centerControlAdded = true;
            }
        }

        function hideCenterControl() {
            if (centerControlAdded) {
                map.removeControl(centerControl);
                centerControlAdded = false;
            }
        }


        const baseMaps = {};
        const overlayMaps = {};
        const layerControl = L.control.layers(baseMaps, overlayMaps);
        let layerControlAdded = false;
        let drawDEMCheck = false;

        let kmzBaseLayers = [];
let kmzLegendControls = [];
        
        L.control.scale().addTo(map);

        const centerControl = L.control({ position: 'topleft' });
        let centerControlAdded = false;

        centerControl.onAdd = function(map) {
            const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-center');
            const button = L.DomUtil.create('a', '', container);
            button.innerHTML = 'âŒ–';
            button.title = 'Center on current shape';
            button.href = '#';

            L.DomEvent.on(button, 'click', (e) => {
                L.DomEvent.stopPropagation(e);
                L.DomEvent.preventDefault(e);
                if (mapRectangleLayer.getLayers().length > 0) {
                    const layer = mapRectangleLayer.getLayers()[0];
                    if (layer.getBounds) {
                        map.fitBounds(layer.getBounds());
                    }
                }
            });

            return container;
        };

        function clearKmzBaseLayers() {
    kmzBaseLayers.forEach(layer => {
        if (map.hasLayer(layer)) {
            map.removeLayer(layer);
        }
        layerControl.removeLayer(layer);
    });

    kmzLegendControls.forEach(ctrl => {
        map.removeControl(ctrl);
    });

    kmzBaseLayers = [];
    kmzLegendControls = [];
    activeKmzLayer = null;
}

        if (window.qt) {
            new QWebChannel(qt.webChannelTransport, channel => {
                window.bridge = channel.objects.bridge;
            });
        }
        
    </script>
</body>
</html>
