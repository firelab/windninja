<!--
******************************************************************************
*
* $Id: map.html
*
* Project:  WindNinja
* Purpose:  Map Layer used to download and display landscape data
* Author:   Mason Willman <mason.willman@usda.gov>
*
******************************************************************************
*
* THIS SOFTWARE WAS DEVELOPED AT THE ROCKY MOUNTAIN RESEARCH STATION (RMRS)
* MISSOULA FIRE SCIENCES LABORATORY BY EMPLOYEES OF THE FEDERAL GOVERNMENT
* IN THE COURSE OF THEIR OFFICIAL DUTIES. PURSUANT TO TITLE 17 SECTION 105
* OF THE UNITED STATES CODE, THIS SOFTWARE IS NOT SUBJECT TO COPYRIGHT
* PROTECTION AND IS IN THE PUBLIC DOMAIN. RMRS MISSOULA FIRE SCIENCES
* LABORATORY ASSUMES NO RESPONSIBILITY WHATSOEVER FOR ITS USE BY OTHER
* PARTIES,  AND MAKES NO GUARANTEES, EXPRESSED OR IMPLIED, ABOUT ITS QUALITY,
* RELIABILITY, OR ANY OTHER CHARACTERISTIC.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*
******************************************************************************
-->

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Leaflet Map</title>
    <style>
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            box-sizing: border-box;
        }
        #map {
            height: 100%;
            width: 100%;
            box-sizing: border-box;
        }
        .leaflet-div-icon {
            background: white;
            border: 2px solid #0077ff;
            border-radius: 50%;
            width: 10px !important;
            height: 10px !important;
            margin-left: -5px !important;
            margin-top: -5px !important;
            box-shadow: 0 0 1px #000;
        }
        .leaflet-drag-target {
            cursor: move !important;
        }
    </style>

    <link rel="stylesheet" href="leaflet/leaflet.css"/>
    <link rel="stylesheet" href="leaflet/draw/src/leaflet.draw.css"/>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- Leaflet and Draw dependencies -->
    <script src="./leaflet/leaflet-src.js"></script>
    <script src="./leaflet/L.KML.js"></script>

    <script src="./leaflet/draw/src/Leaflet.draw.js"></script>
    <script src="./leaflet/draw/src/Leaflet.Draw.Event.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.Poly.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.SimpleShape.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.Rectangle.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.Marker.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.CircleMarker.js"></script>
    <script src="./leaflet/draw/src/edit/handler/Edit.Circle.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Feature.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Polyline.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Polygon.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.SimpleShape.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Rectangle.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Circle.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.Marker.js"></script>
    <script src="./leaflet/draw/src/draw/handler/Draw.CircleMarker.js"></script>
    <script src="./leaflet/draw/src/ext/TouchEvents.js"></script>
    <script src="./leaflet/draw/src/ext/LatLngUtil.js"></script>
    <script src="./leaflet/draw/src/ext/GeometryUtil.js"></script>
    <script src="./leaflet/draw/src/ext/LineUtil.Intersect.js"></script>
    <script src="./leaflet/draw/src/ext/Polyline.Intersect.js"></script>
    <script src="./leaflet/draw/src/ext/Polygon.Intersect.js"></script>
    <script src="./leaflet/draw/src/Control.Draw.js"></script>
    <script src="./leaflet/draw/src/Tooltip.js"></script>
    <script src="./leaflet/draw/src/Toolbar.js"></script>
    <script src="./leaflet/draw/src/draw/DrawToolbar.js"></script>
    <script src="./leaflet/draw/src/edit/EditToolbar.js"></script>
    <script src="./leaflet/draw/src/edit/handler/EditToolbar.Edit.js"></script>
    <script src="./leaflet/draw/src/edit/handler/EditToolbar.Delete.js"></script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
</head>
<body>
    <div id="map" style="border: 1px solid #ccc"></div>
    <script>
        const apiKey = "pk.eyJ1IjoiYm5vcmRncmVuIiwiYSI6ImNsZmxuMHowZzAzaTczeG80ZXR3a2ZnNHEifQ.kc7P57DJg8tyDMjjP7czuQ";

        const mapBaseLayer = L.tileLayer(`https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=${apiKey}`, {
            tileSize: 512,
            maxZoom: 18,
            zoomOffset: -1,
            id: 'mapbox/streets-v11'
        });

        const map = new L.Map('map', {
            layers: [mapBaseLayer],
            center: new L.LatLng(43.62455, -113.2971),
            zoom: 8
        });

        const mapRectangleLayer = new L.FeatureGroup();
        map.addLayer(mapRectangleLayer);

        const rectangleDrawer = new L.Draw.Rectangle(map);

        function sendBoundingBox(layer) {
            const bounds = layer.getBounds();
            const bboxData = {
                north: bounds.getNorth(),
                south: bounds.getSouth(),
                east: bounds.getEast(),
                west: bounds.getWest()
            };
            if (window.bridge?.receiveBoundingBox) {
                window.bridge.receiveBoundingBox(JSON.stringify(bboxData));
            }
        }

        function drawBoundingBox(north, south, east, west) {
            mapRectangleLayer.clearLayers();
            const bounds = [[south, west], [north, east]];
            const rectangle = L.rectangle(bounds).addTo(mapRectangleLayer);
            rectangle.editing.enable();
        }

        function drawDEM(DEMCorners) {
            mapRectangleLayer.clearLayers();

            const rectangleCorners = [
                [DEMCorners[1], DEMCorners[0]], // NE
                [DEMCorners[3], DEMCorners[2]], // SE
                [DEMCorners[5], DEMCorners[4]], // SW
                [DEMCorners[7], DEMCorners[6]], // NW
                [DEMCorners[1], DEMCorners[0]]  // NE
            ];

            const rectangle = L.polygon(rectangleCorners, {
                color: 'black',
                weight: 2,
                fill: false
            }).addTo(mapRectangleLayer);
        }

        function startRectangleDrawing() {
            mapRectangleLayer.clearLayers();
            rectangleDrawer.enable();
        }

        function stopRectangleDrawing() {
            mapRectangleLayer.clearLayers();
            rectangleDrawer.disable();
        }

        async function loadKmzFromBase64(kmlData) {
            const binary = atob(kmlData);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            const zip = await JSZip.loadAsync(bytes.buffer);

            const kmlEntries = Object.values(zip.files).filter(entry =>
                entry.name.toLowerCase().endsWith('.kml')
            );
            const legendEntries = Object.values(zip.files).filter(entry =>
                entry.name.toLowerCase().endsWith('.bmp')
            );

            if (kmlEntries.length === 0) {
                alert('No KML files found in this KMZ.');
                return;
            }

            for (const entry of kmlEntries) {
                const kmlText = await entry.async('string');
                const parser = new DOMParser();
                const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
                const kmlLayer = new L.KML(kmlDoc);

                const kmlLegendLayer = L.layerGroup([kmlLayer]);

                const layerName = entry.name;

                const legendControl = L.control({ position: 'bottomright' });
                legendControl.onAdd = function () {
                    const container = L.DomUtil.create('div', 'kmz-legend');
                    container.style.background = 'white';
                    container.style.padding = '4px';
                    container.style.borderRadius = '6px';
                    container.style.maxWidth = '250px';
                    container.innerHTML = `<strong>${layerName}</strong><br>`;

                    legendEntries.forEach(async (legendEntry) => {
                        const blob = await legendEntry.async('blob');
                        const url = URL.createObjectURL(blob);
                        const img = new Image();
                        img.src = url;
                        img.style.maxWidth = '80%';
                        img.style.marginTop = '6px';
                        container.appendChild(img);
                    });

                    return container;
                };

                kmlLegendLayer.on('add', () => legendControl.addTo(map));
                kmlLegendLayer.on('remove', () => legendControl.remove());

                layerControl.addOverlay(kmlLegendLayer, layerName);
                kmlLegendLayer.addTo(map);
            }
        }


        map.on('draw:created', ({ layer }) => {
            mapRectangleLayer.clearLayers();
            mapRectangleLayer.addLayer(layer);
            layer.editing.enable();
            sendBoundingBox(layer);
            layer.on('edit', () => sendBoundingBox(layer));
        });

        const baseMaps = {};
        const overlayMaps = {};
        const layerControl = L.control.layers(baseMaps, overlayMaps).addTo(map);
        L.control.scale().addTo(map);

        new QWebChannel(qt.webChannelTransport, channel => {
            window.bridge = channel.objects.bridge;
        });

    </script>
</body>
</html>
